#ifndef SPARSE_VECTOR_HPP
#define SPARSE_VECTOR_HPP

#include "Vector.hpp"
#include "Matrix.hpp"
#include <algorithm>

template<class T> class SparseVector{
private:
	//Add your data members here!
	Vector<T> mData; 
	std::vector<unsigned int> mIndices; 
	std::vector<unsigned int> mValues;  
public:
	//creates an empty vector of dimensionality 0.
	SparseVector(): mData(0){
	}
	// Creates a vector of dimensionality dim. It starts with 0 nonzero elements
	// which need to be set using setValue
	SparseVector(unsigned int dim): mData(dim){
	}

	// assignment operators and copy constructor should be automatically
	// generated by the compiler when using a std::vector for internal storing.
	// However, test that assignment works!

	//sets the value v_i of the vector. if it does not exist it is added
	void setValue(unsigned int index, T value){
		auto lower = std::lower_bound(mIndices.begin(), mIndices.end(), index);
		if(lower == mIndices.end()){
			if(value!=0){
				// Add only non-zero value
				mIndices.push_back(index);
				mValues.push_back(value);
			} // Surely push it back!
			Vector<T> v(mData.size());
			v
			.push_back(value);
		}else {
			mData[*lower] = value; 
			mValues[std::distance(mIndices.begin(), lower)] = value;
		}
		
		if(mIndices.capacity()==0){
			mIndices.push_back(index);
			mValues.push_back(value);
			mData[index] = value; 
		} else{
			if(mIndices.back() < index){
				mIndices.push_back(index);
				mValues.push_back(value);
				mData[index] = value; 
			}
		}
	}

	//returns the value v_i of the vector. Returns 0 if the value is not stored
	T getValue(unsigned int index) const{
		auto lower = std::lower_bound(mIndices.begin(), mIndices.end(), index);
		if(lower==mIndices.end()){
			return 0.0;
		}else {
			return mData[index];
		}
	}

	//returns the dimensionality of the vector
	unsigned int size() const{
		return mData.size();
	}

	// returns the number stored elements
	unsigned int nonZeroes() const{
		return mIndices.size();
	}
	//returns the index of the ith stored nonzero entry (in increasing order)
	unsigned int indexNonZero(unsigned int i) const{
		return mIndices[i];
	}
	//returns the value of the ith stored nonzero entry (in increasing order)
	T valueNonZero(unsigned int i) const{
		return mValues[i];
	}

	//adds x too the current vector
	SparseVector<T>& operator+= (SparseVector<T> const& x){
		unsigned int size_diff = x.size() - mData.size();
		if(size_diff>0){
			SparseVector result(mData.getStorage().size() + size_diff);
			return result;
		} else{
			return x;
		}
	}
	//subtracts x from the current vector
	SparseVector<T>& operator-= (SparseVector<T> const& x){
		return x;
	}
};


// computes z= x+y, equivalent to z=x, z+=y
template<class T>
SparseVector<T> operator+(SparseVector<T> const& x, SparseVector<T> const& y){
	return x;
}

// computes z= x-y, equivalent to z=x, z-=y
template<class T>
SparseVector<T> operator-(SparseVector<T> const& x, SparseVector<T> const& y){
	return x;
}


// computes the matrix-vector product of a dense matrix and sparse vector z=Ax.
// The result is a dense vector.
template<class T>
Vector<T> operator* (Matrix<T> const& A, SparseVector<T> const& x){
	Vector<T> result(A.GetNumberOfRows());
	return result;
}

// computes the matrix-vector product of a dense matrix and sparse vector z=x^TA.
// The result is a dense vector.
template<class T>
Vector<T> operator* (SparseVector<T> const& x, Matrix<T> const& A){
	Vector<T> result(A.GetNumberOfColumns());
	return result;
}


#endif
