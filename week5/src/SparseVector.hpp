#ifndef SPARSE_VECTOR_HPP
#define SPARSE_VECTOR_HPP

#include "Vector.hpp"
#include "Matrix.hpp"
#include <algorithm>

template<class T> class SparseVector{
private:
	//Add your data members here!
	int mDim; 
	std::vector<unsigned int> mIndices; 
	std::vector<T> mValues;  
public:
	//creates an empty vector of dimensionality 0.
	SparseVector(){
		mDim = 0;
	}
	// Creates a vector of dimensionality dim. It starts with 0 nonzero elements
	// which need to be set using setValue
	SparseVector(unsigned int dim){
		mDim = dim;
	}

	// assignment operators and copy constructor should be automatically
	// generated by the compiler when using a std::vector for internal storing.
	// However, test that assignment works!

	//sets the value v_i of the vector. if it does not exist it is added
	void setValue(unsigned int index, T value){
		auto lower = std::lower_bound(mIndices.begin(), mIndices.end(), index);
		if(lower == mIndices.end()){
			// Bigger than any existing element
			mIndices.push_back(index);
			mValues.push_back(value);
		}else if(*lower==index){
			// Existing element
			int dist = std::distance(mIndices.begin(), lower);
			mValues[dist] = value;
		}else {
			// Insert element
			int dist = std::distance(mIndices.begin(), lower);
			mValues.insert(mValues.begin() + dist, value);
			mIndices.insert(mIndices.begin() + dist, index);
		}
	}

	//returns the value v_i of the vector. Returns 0 if the value is not stored
	T getValue(unsigned int index) const{
		auto lower = std::lower_bound(mIndices.begin(), mIndices.end(), index);
		if(lower != mIndices.end() && *lower == index){
			int dist = std::distance(mIndices.begin(), lower);
			return mValues[dist];
		}
		return 0.0;
	}

	//returns the dimensionality of the vector
	unsigned int size() const{
		return mDim;
	}

	// returns the number stored elements
	unsigned int nonZeroes() const{
		return mIndices.size();
	}
	//returns the index of the ith stored nonzero entry (in increasing order)
	unsigned int indexNonZero(unsigned int i) const{
		return mIndices[i];
	}
	//returns the value of the ith stored nonzero entry (in increasing order)
	T valueNonZero(unsigned int i) const{
		return mValues[i];
	}

	//adds x too the current vector
	SparseVector<T>& operator+= (SparseVector<T> const& x){
		// Adding non-zero element of x 
		for(int i=0; i<x.nonZeroes(); i++){
			int index = x.indexNonZero(i);
			T result = (*this).getValue(index) + x.valueNonZero(i);
			(*this).setValue(index, result);
		}
		return *this;
	}
	//subtracts x from the current vector
	SparseVector<T>& operator-= (SparseVector<T> const& x){
		// Adding non-zero element of x 
		for(int i=0; i<x.nonZeroes(); i++){
			int index = x.indexNonZero(i);
			T result = (*this).getValue(index) - x.valueNonZero(i);
			(*this).setValue(index, result);
		}
		return *this;
	}
};


// computes z= x+y, equivalent to z=x, z+=y
template<class T>
SparseVector<T> operator+(SparseVector<T> const& x, SparseVector<T> const& y){
	SparseVector<T> z(x);
	z += y;
	return z;
}

// computes z= x-y, equivalent to z=x, z-=y
template<class T>
SparseVector<T> operator-(SparseVector<T> const& x, SparseVector<T> const& y){
	SparseVector<T> z(x);
	z -= y;
	return z;
}


// computes the matrix-vector product of a dense matrix and sparse vector z=Ax.
// The result is a dense vector.
template<class T>
Vector<T> operator* (Matrix<T> const& A, SparseVector<T> const& x){
	Vector<T> result(A.GetNumberOfRows());
	if (x.nonZeroes()>0){
		for(int i=0; i<A.GetNumberOfRows(); i++){
			for(int j=0; j<x.nonZeroes(); j++){
				int j_prime = x.indexNonZero(j);
				result[i] += A(i,j_prime)*x.getValue(j_prime);
			}	
		}
	}
	return result;
}

// computes the matrix-vector product of a dense matrix and sparse vector z=x^TA.
// The result is a dense vector.
template<class T>
Vector<T> operator* (SparseVector<T> const& x, Matrix<T> const& A){
	Vector<T> result(A.GetNumberOfColumns());
	if (x.nonZeroes()>0){
		for(int i=0; i<A.GetNumberOfColumns(); i++){
			for(int j=0; j<x.nonZeroes(); j++){
				int j_prime = x.indexNonZero(j);
				result[i] += x.getValue(j_prime)*A(j_prime,i);
			}	
		}
	}
	return result;
}

#endif